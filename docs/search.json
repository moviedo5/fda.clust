[{"path":"/articles/Introduction.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"fda.clust: Clustering Functional Data","text":"fda.clust package provides advanced tools clustering functional data. Functional data, curves functions observed continuum (like time space), appear areas like economics, biology, engineering. Clustering data requires specialized approaches distinct traditional multivariate clustering algorithms. vignette introduces main functionalities fda.clust package demonstrates cluster simulated real-world functional data.","code":""},{"path":"/articles/Introduction.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"fda.clust: Clustering Functional Data","text":"","code":"# Install from source (if not already installed) devtools::install_github(\"username/fda.clust\")"},{"path":"/articles/Introduction.html","id":"simulating-functional-data","dir":"Articles","previous_headings":"","what":"Simulating Functional Data","title":"fda.clust: Clustering Functional Data","text":"rprocKclust() function simulates functional data specific models, enabling testing clustering methods.","code":"library(fda.clust) set.seed(123) t <- seq(0, 2 * pi, length.out = 101) res <- rprocKclust(t, n = c(30, 50, 40),                    process = c(\"cos_sin\", \"sin\", \"cos\"),                    c = c(-1, 1, 1), k = c(NA, NA, NA),                    s = c(0.2, 0.3, 0.1)) sim_data <- res$X group <- res$groups plot(sim_data, type = 'l', col = rainbow(3)[group])"},{"path":"/articles/Introduction.html","id":"clustering-methods","dir":"Articles","previous_headings":"","what":"Clustering Methods","title":"fda.clust: Clustering Functional Data","text":"fda.clust package supports several clustering methods functional data, including hierarchical clustering, k-means clustering, mean-shift clustering.","code":""},{"path":"/articles/Introduction.html","id":"k-means-clustering-fkmeans","dir":"Articles","previous_headings":"Clustering Methods","what":"K-means Clustering (fkmeans)","title":"fda.clust: Clustering Functional Data","text":"","code":"kmeans_result <- fkmeans(sim_data, ncl = 3) ## Warning: executing %dopar% sequentially: no parallel backend registered plot(sim_data, type = 'l', col = rainbow(3)[kmeans_result$cluster])"},{"path":"/articles/Introduction.html","id":"evaluation-of-clustering-performance","dir":"Articles","previous_headings":"","what":"Evaluation of Clustering Performance","title":"fda.clust: Clustering Functional Data","text":"assess clustering quality, package offers function fclust.measures, computes indices like: Silhouette Index: Measures cohesion separation clusters. Dunn Index: Measures ratio smallest inter-cluster distance largest intra-cluster distance. Davies-Bouldin Index: Measures average similarity clusters. Calinski-Harabasz Index: Measures ratio -cluster dispersion within-cluster dispersion.","code":""},{"path":"/articles/Introduction.html","id":"example-of-clustering-performance-evaluation","dir":"Articles","previous_headings":"Evaluation of Clustering Performance","what":"Example of Clustering Performance Evaluation","title":"fda.clust: Clustering Functional Data","text":"","code":"# Calculate evaluation indices using fclust.measures indices <- list(   silhouette = fclust.measures(sim_data, clusters = kmeans_result$cluster, index = 'silhouette'),   dunn = fclust.measures(sim_data, clusters = kmeans_result$cluster, index = 'dunn'),   db = fclust.measures(sim_data, clusters = kmeans_result$cluster, index = 'db'),   ch = fclust.measures(sim_data, clusters = kmeans_result$cluster, index = 'ch') )  print(indices) ## $silhouette ## [1] 0.3004197 ##  ## $dunn ## [1] 0.4106774 ##  ## $db ## [1] 2.462815 ##  ## $ch ## [1] 82.16625"},{"path":"/articles/Introduction.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"fda.clust: Clustering Functional Data","text":"fda.clust package provides robust tools clustering functional data, including hierarchical, k-means, mean-shift clustering. supports simulation functional data, allowing users benchmark clustering methods. information, refer official package documentation GitHub repository.","code":""},{"path":"/articles/Simulations.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Simulating Functional Data for Clustering with `fda.clust`","text":"fda.clust package provides tools simulate functional data specific latent processes clustering structures. document demonstrates use key simulation functions: rprocKclust, rprocKmu, rproc2clust, rproc2mu.","code":""},{"path":"/articles/Simulations.html","id":"simulating-functional-data-for-two-groups-sine-and-cosine-processes","dir":"Articles","previous_headings":"","what":"Simulating Functional Data for Two Groups (Sine and Cosine Processes)","title":"Simulating Functional Data for Clustering with `fda.clust`","text":"rproc2clust function generates functional data two distinct groups, specific latent processes.","code":"library(fda.clust) t <- seq(0, 2 * pi, length.out = 101) # Generate latent processes latent_mu <- rproc2mu(t, process1 = \"sin\", process2 = \"cos\",                        c.1 = 1, c.2 = -1)  # Simulate functional data for two groups group_data <- rproc2clust(n.1 = 50, n.2 = 50,                            mu.1 = latent_mu$mu.1, mu.2 = latent_mu$mu.2,                            s.1 = \"vexponential\", s.2 = \"vexponential\")  plot(group_data$X, col = group_data$colors, main = \"Two Groups: Sine and Cosine\") lines(group_data$X.hat, lwd = 2, col = group_data$color)"},{"path":"/articles/Simulations.html","id":"simulating-functional-data-for-four-groups-poly1-and-poly2-processes","dir":"Articles","previous_headings":"","what":"Simulating Functional Data for Four Groups (Poly1 and Poly2 Processes)","title":"Simulating Functional Data for Clustering with `fda.clust`","text":"rprocKclust function creates functional data combining latent processes noise multiple groups.","code":"t <- seq(0, 1, length.out = 101) clustering_data <- rprocKclust(t,                                 n = c(40, 40, 40, 40),                                 process = c(\"poly1\", \"poly1\", \"poly2\", \"poly2\"),                                 c = c(10, -10, 15, -15),                                 k = c(1, 2, 1.5, 2.5),                                 s = c(0.3, 0.3, 0.2, 0.2))  plot(clustering_data$X, col = clustering_data$colors, main = \"Four Groups: Poly1 and Poly2\") lines(clustering_data$X.hat, lwd = 2, col = clustering_data$color)"},{"path":"/articles/Simulations.html","id":"customizing-simulations","dir":"Articles","previous_headings":"","what":"Customizing Simulations","title":"Simulating Functional Data for Clustering with `fda.clust`","text":"rproc2clust function allows customization noise structure specifying parameters par.list.1 par.list.2.","code":"par.list.1 <- list(scale = 0.8, theta = 0.3, H = 0.5) par.list.2 <- list(scale = 0.2, theta = 0.3, H = 0.5)  custom_group_data <- rproc2clust(n.1 = 50, n.2 = 50,                                   mu.1 = latent_mu$mu.1,                                   mu.2 = latent_mu$mu.2,                                   s.1 = 1, s.2 = 1.5,                                   par.list.1 = par.list.1,                                   par.list.2 = par.list.2)  plot(custom_group_data$X, col = custom_group_data$colors, main = \"Custom Noise Structure\") lines(custom_group_data$X.hat, lwd = 2, col = custom_group_data$color)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Manuel Febrero-Bande. Author. Manuel Oviedo-de la Fuente. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Febrero-Bande M, Oviedo-de la Fuente M (2024). fda.clust: Clustering Methods Functional Data Analysis. R package version 0.1.1, https://CRAN.R-project.org/package=fda.clust.","code":"@Manual{,   title = {fda.clust: Clustering Methods for Functional Data Analysis},   author = {Manuel Febrero-Bande and Manuel {Oviedo-de la Fuente}},   year = {2024},   note = {R package version 0.1.1},   url = {https://CRAN.R-project.org/package=fda.clust}, }"},{"path":"/index.html","id":"package-overview","dir":"","previous_headings":"","what":"Package Overview","title":"Clustering Methods for Functional Data Analysis","text":"fda.clust package offers: functional k-means, hierarchical clustering, functional dbscan. Visualization tools: Plots graphical representations explore understand resulting clusters. Cluster validation: Metrics evaluating quality stability obtained partitions. goal provide comprehensive toolbox users interested segmenting functional data—research applying advanced statistical methodologies real-world problems.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Clustering Methods for Functional Data Analysis","text":"available, can install development version fda.clust GitHub. example: ##Example simple example shows might load package apply clustering method (note: placeholder may need adjustment functions implemented):","code":"# install.packages(\"devtools\") # if you don't have it already library(devtools) devtools::install_github(\"username/fda.clust\") # Or: # remotes::install_github(\"username/fda.clust\") library(fda.clust)  # Suppose 'fd_data' is a functional data object # cluster_result <- fda_clust_kmeans(fd_data, centers = 3) # plot(cluster_result)"},{"path":"/index.html","id":"issues--feature-requests","dir":"","previous_headings":"","what":"Issues & Feature Requests","title":"Clustering Methods for Functional Data Analysis","text":"reporting issues, bugs, feature requests, etc., please use Github Issues. contributions feedback always welcome.","code":""},{"path":"/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Clustering Methods for Functional Data Analysis","text":"hands introduction can found reference vignette.","code":""},{"path":"/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Clustering Methods for Functional Data Analysis","text":"Febrero-Bande, M. Oviedo de la Fuente, M. (2012). Statistical Computing Functional Data Analysis: R Package fda.usc. Journal Statistical Software, 51(4):1-28, DOI","code":""},{"path":"/reference/fclust.measures.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Data Clustering Measures — fclust.measures","title":"Functional Data Clustering Measures — fclust.measures","text":"function computes clustering evaluation measures functional data objects class 'fdata'. supports calculation Dunn, Davies-Bouldin, Calinski-Harabasz, Silhouette indices. Distances computed using metric.lp function fda.usc package default, users can specify different distance metric via 'metric' parameter. Cluster means calculated using appropriate function, can specified user via 'center_func' argument.","code":""},{"path":"/reference/fclust.measures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Data Clustering Measures — fclust.measures","text":"","code":"fclust.measures(   X,   clusters,   index = \"silhouette\",   metric = metric.lp,   par.metric = list(),   center_func = func.mean )"},{"path":"/reference/fclust.measures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Data Clustering Measures — fclust.measures","text":"X fdata object containing functional data. rows represent observations columns represent discrete evaluations functional data. clusters vector containing cluster assignments observation fdata object. index character string indicating measure compute. Possible options \"silhouette\" (default), \"dunn\", \"db\" (Davies-Bouldin), \"ch\" (Calinski-Harabasz). metric function specifying distance metric used. default 'metric.lp'. par.metric list parameters passed 'metric' function. center_func function compute cluster means, possible options like 'func.mean', 'func.trim.mode', user-defined functions.","code":""},{"path":"/reference/fclust.measures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Data Clustering Measures — fclust.measures","text":"value selected clustering measure.","code":""},{"path":"/reference/fclust.measures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Data Clustering Measures — fclust.measures","text":"","code":"set.seed(123) t <- seq(0, 2 * pi, length.out = 101) res <- rprocKclust(t, n = c(30, 50, 40),                     process = c(\"cos_sin\", \"sin\", \"cos\"),                     c = c(-1, 1, 1), k = c(NA, NA, NA),                     s = c(0.2, 0.3, 0.1)) X <- res$X clusters <- res$groups silhouette_val <- fclust.measures(X, clusters, index = \"silhouette\") #> Warning: executing %dopar% sequentially: no parallel backend registered dunn_val <- fclust.measures(X, clusters, index = \"dunn\") db_val <- fclust.measures(X, clusters, index = \"db\") ch_val <- fclust.measures(X, clusters, index = \"ch\") print(silhouette_val) #> [1] 0.407778 print(dunn_val) #> [1] 0.8951075 print(db_val) #> [1] 1.507773 print(ch_val) #> [1] 118.2537"},{"path":"/reference/fdbscan.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional DBSCAN Optimization and Clustering — fdbscan","title":"Functional DBSCAN Optimization and Clustering — fdbscan","text":"Perform DBSCAN clustering functional data optimize parameters `eps` `minPts`.","code":""},{"path":"/reference/fdbscan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional DBSCAN Optimization and Clustering — fdbscan","text":"","code":"fdbscan(   fdataobj,   eps,   minPts = 5,   metric = metric.lp,   par.metric = list(lp = 2) )"},{"path":"/reference/fdbscan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional DBSCAN Optimization and Clustering — fdbscan","text":"fdataobj object class `fdata` containing functional data. eps Neighborhood parameter (`eps`) DBSCAN. NULL, estimated automatically. minPts Minimum cluster size (`minPts`). NULL, estimated automatically. metric Metric function compute distances. Default `metric.lp`. par.metric List arguments metric function.","code":""},{"path":"/reference/fdbscan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional DBSCAN Optimization and Clustering — fdbscan","text":"list following elements: `optimal`: Data frame best parameters (`eps`, `minPts`, `quality`). `model`: DBSCAN clustering model refined clusters. `results`: Data frame combinations `eps` `minPts` tested.","code":""},{"path":"/reference/fdbscan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional DBSCAN Optimization and Clustering — fdbscan","text":"","code":"if (FALSE) { # \\dontrun{ t <- seq(0, 2 * pi, length.out = 101) res <- rprocKclust(t, n = c(30, 50, 40), process = c(\"cos_sin\", \"sin\", \"cos\"),                    c = c(-1, 1, 1), k = c(NA, NA, NA), s = c(0.2, 0.3, 0.1)) opt_results <- optim.fdbscan(res$X, metric = metric.lp, par.metric = list(lp = 2)) print(opt_results$optimal) plot(res$X, col = opt_results$model$cluster+1, main = \"Optimal DBSCAN Clustering\") } # }"},{"path":"/reference/fhclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical Clustering for Functional Data — fhclust","title":"Hierarchical Clustering for Functional Data — fhclust","text":"Performs hierarchical clustering functional data using specified clustering method. distance functional observations calculated using distance measures fda.usc package.","code":""},{"path":"/reference/fhclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical Clustering for Functional Data — fhclust","text":"","code":"fhclust(fdataobj, method = \"ward.D2\")"},{"path":"/reference/fhclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical Clustering for Functional Data — fhclust","text":"fdataobj object class fdata representing functional data clustered. row corresponds functional observation. method character string specifying agglomeration method used. Possible values \"ward.D2\", \"single\", \"complete\", \"average\", \"mcquitty\", \"median\", \"centroid\". Defaults \"ward.D2\".","code":""},{"path":"/reference/fhclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical Clustering for Functional Data — fhclust","text":"object class hclust, describes tree produced hierarchical clustering process. object following components: merge numeric matrix describing merge history. height height mergers occurred. order vector giving order objects. labels labels objects clustered. call call produced result. method agglomeration method used.","code":""},{"path":"/reference/fhclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hierarchical Clustering for Functional Data — fhclust","text":"fhclust function applies hierarchical clustering functional data, using distances calculated via fda.usc::metric.lp function. method hierarchical clustering can agglomeration methods available hclust. function useful clustering functional data time series, curves, functional representations. function returns object class hclust, can plotted interpreted dendrogram.","code":""},{"path":[]},{"path":"/reference/fhclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical Clustering for Functional Data — fhclust","text":"","code":"if (FALSE) { # \\dontrun{ t <- seq(0, 2 * pi, length.out = 101) res <- rprocKclust(t, n = c(30, 50, 40), process = c(\"cos_sin\", \"sin\", \"cos\"),                    c = c(-1, 1, 1), k = c(NA, NA, NA), s = c(0.2, 0.3, 0.1)) # Perform hierarchical clustering using the default method (ward.D2) result <- fhclust(res$X, method = \"ward.D2\") # Plot the dendrogram plot(result, main = \"Dendrogram of Functional Data (Ward's Method)\")  # Cut the dendrogram into  clusters groups <- cutree(result, k = 3) print(table(res$groups,groups)) } # }"},{"path":"/reference/fhcust.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical Clustering for Functional Data — fhcust","title":"Hierarchical Clustering for Functional Data — fhcust","text":"Performs hierarchical clustering functional data using specified clustering method. distance functional observations calculated using distance measures fda.usc package.","code":""},{"path":"/reference/fhcust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical Clustering for Functional Data — fhcust","text":"","code":"fhcust(fdataobj, method = \"ward.D2\")"},{"path":"/reference/fhcust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical Clustering for Functional Data — fhcust","text":"fdataobj object class fdata representing functional data clustered. row corresponds functional observation. method character string specifying agglomeration method used. Possible values \"ward.D2\", \"single\", \"complete\", \"average\", \"mcquitty\", \"median\", \"centroid\". Defaults \"ward.D2\".","code":""},{"path":"/reference/fhcust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical Clustering for Functional Data — fhcust","text":"object class hclust, describes tree produced hierarchical clustering process. object following components: merge numeric matrix describing merge history. height height mergers occurred. order vector giving order objects. labels labels objects clustered. call call produced result. method agglomeration method used.","code":""},{"path":"/reference/fhcust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hierarchical Clustering for Functional Data — fhcust","text":"fhcust function applies hierarchical clustering functional data, using distances calculated via fda.usc::metric.lp function. method hierarchical clustering can agglomeration methods available hclust. function useful clustering functional data time series, curves, functional representations. function returns object class hclust, can plotted interpreted dendrogram.","code":""},{"path":[]},{"path":"/reference/fhcust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical Clustering for Functional Data — fhcust","text":"","code":"if (FALSE) { # \\dontrun{ t <- seq(0, 2 * pi, length.out = 101) res <- rprocKclust(t, n = c(30, 50, 40), process = c(\"cos_sin\", \"sin\", \"cos\"),                    c = c(-1, 1, 1), k = c(NA, NA, NA), s = c(0.2, 0.3, 0.1)) # Perform hierarchical clustering using the default method (ward.D2) result <- fhcust(res$X, method = \"ward.D2\") # Plot the dendrogram plot(result, main = \"Dendrogram of Functional Data (Ward's Method)\")  # Cut the dendrogram into  clusters groups <- cutree(result, k = 3) print(table(res$groups,groups)) } # }"},{"path":"/reference/fkmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"K-Means Clustering for functional data — fkmeans","title":"K-Means Clustering for functional data — fkmeans","text":"Perform k-means clustering functional data.","code":""},{"path":"/reference/fkmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K-Means Clustering for functional data — fkmeans","text":"","code":"fkmeans(   fdataobj,   ncl = 2,   metric = metric.lp,   dfunc = func.trim.FM,   max.iter = 100,   par.metric = NULL,   par.dfunc = list(trim = 0.05),   method = \"sample\",   cluster.size = 5,   draw = TRUE,   ... )"},{"path":"/reference/fkmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K-Means Clustering for functional data — fkmeans","text":"fdataobj fdata class object. ncl See details section. metric Metric function, default metric.lp. dfunc Type depth measure, default FM depth. max.iter Maximum number iterations detection centers. par.metric List arguments pass metric function. par.dfunc List arguments pass dfunc function . method Method selecting initial centers. method=\"Sample\" (default) takes n times random selection ncl centers. ncl curves greater distance initial centers. method=\"Exact\" calculated combinations (< 1e+6) ncl centers. ncl curves greater distance initial centers (method may slow). cluster.size Minimum cluster size (default 5). cluster fewer curves, eliminated process continued less cluster. draw =TRUE, draw curves color centers. ... arguments passed methods.","code":""},{"path":"/reference/fkmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K-Means Clustering for functional data — fkmeans","text":"Return: cluster: Indexes groups assigned. centers: Curves centers.","code":""},{"path":"/reference/fkmeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"K-Means Clustering for functional data — fkmeans","text":"method searches locations around grouped data (predetermined number groups). ncl=NULL, randomizes initial centers, ncl=2 using kmeans.center.ini function. ncl integer, indicating number groups classify, selected ncl initial centers using kmeans.center.ini function. ncl vector integers, indicating position initial centers length(ncl) equal number groups. ncl fdata class objecct, ncl initial centers curves nrow(ncl) number groups.","code":""},{"path":"/reference/fkmeans.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"K-Means Clustering for functional data — fkmeans","text":"Hartigan, J. . Wong, M. . (1979). K-means clustering algorithm. Applied Statistics 28, 100 \\-108.","code":""},{"path":[]},{"path":"/reference/fkmeans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"K-Means Clustering for functional data — fkmeans","text":"Manuel Febrero-Bande, Manuel Oviedo de la Fuente manuel.oviedo@udc.es","code":""},{"path":"/reference/fkmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"K-Means Clustering for functional data — fkmeans","text":"","code":"if (FALSE) { # \\dontrun{ library(fda.usc) data(phoneme) ind <- c(1:50,101:150,201:250) clas <- as.numeric(phoneme$classlearn[ind]) fdataobj <- phoneme$learn[ind,] # Unsupervised classification out.fd1 <- fkmeans(fdataobj,ncl=3,draw=TRUE) out.fd2 <- fkmeans(fdataobj,ncl=3,draw=TRUE,method=\"exact\") # Different Depth function ind2 <- c(17,77,126) out.fd3 <- fkmeans(fdataobj,ncl=fdataobj[ind2,],draw=FALSE,                      dfunc =func.trim.FM,par.dfunc=list(trim=0.1)) out.fd4 <- fkmeans(fdataobj, ncl=fdataobj[ind2,],                       draw=FALSE, dfunc = func.med.FM) table(clas,out.fd1$cluster ) table(clas,out.fd4$cluster ) } # }"},{"path":"/reference/fmeanshift.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Mean Shift Clustering — fmeanshift","title":"Functional Mean Shift Clustering — fmeanshift","text":"function applies mean shift clustering algorithm functional data object class fdata.  uses kernel-based approach iteratively shift points towards high-density regions.","code":""},{"path":"/reference/fmeanshift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Mean Shift Clustering — fmeanshift","text":"","code":"fmeanshift(   fdataobj,   h = -0.15,   metric = metric.lp,   par.metric = list(lp = 2),   derr = 0.1 )"},{"path":"/reference/fmeanshift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Mean Shift Clustering — fmeanshift","text":"fdataobj object class fdata containing functional data clustered. h bandwidth parameter. h < 0, bandwidth estimated using h.default function prob = abs(h). Defaults h = -0.15. metric function compute distance elements fdataobj. Defaults metric.lp. par.metric list additional parameters passed metric function. default, list(lp = 2) compute L2 distance. derr convergence tolerance parameter used determine mean shift converged. Defaults derr = 0.1.","code":""},{"path":"/reference/fmeanshift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Mean Shift Clustering — fmeanshift","text":"list following components: cluster integer vector indicating cluster assignment observation fdataobj. centers fdata object representing centers clusters.","code":""},{"path":"/reference/fmeanshift.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional Mean Shift Clustering — fmeanshift","text":"fmeanshift algorithm iteratively shifts observation towards mode neighborhood, defined using kernel bandwidth h. procedure continues shift distance smaller convergence threshold controlled derr. distance functional data computed using distance function metric, defaults L2 distance provided metric.lp fda.usc package. bandwidth h controls size neighborhood c onsidered shift.","code":""},{"path":[]},{"path":"/reference/fmeanshift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Mean Shift Clustering — fmeanshift","text":"","code":"if (FALSE) { # \\dontrun{ set.seed(8:1) t <- seq(0, 2 * pi, length.out = 101) res <- rprocKclust(t, n = c(40, 40), process = c(\"cos_sin\", \"sin\"),                    c = c(-1, 2), k = c(NA, NA), s = c(0.3, 0.3)) # Run mean shift clustering with automatic bandwidth selection result <- fmeanshift(res$X) # Display cluster assignments and centers table(result$cluster,res$groups) plot(result$centers) plot(res$X, col = result$cluster, main = \"functional meanshift\") } # }"},{"path":"/reference/rproc2clust.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Functional Data for Clustering — rproc2clust","title":"Simulate Functional Data for Clustering — rproc2clust","text":"Simulates functional data based specified parameters clustering analysis within `fda.clust` package. uses `rproc2mu` generate latent processes `rproc2fdata` `fda.usc` generate  functional data.","code":""},{"path":"/reference/rproc2clust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Functional Data for Clustering — rproc2clust","text":"","code":"rproc2clust(   n.1 = 51,   n.2 = n.1,   mu.1,   mu.2,   s.1 = 1,   s.2 = 1,   par.list.1 = FALSE,   par.list.2 = FALSE,   ... )"},{"path":"/reference/rproc2clust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Functional Data for Clustering — rproc2clust","text":"n.1, n.2 Integers specifying number curves generated first  second groups, respectively. mu.1, mu.2 Objects class fdata representing theoretical mean functions first second groups, respectively. s.1, s.2 Numeric values specifying standard deviation noise added first second groups, respectively. See sigma argument rproc2fdata function. par.list.1, par.list.2 Optional lists additional parameters passed rproc2fdata generating first second groups, respectively. set FALSE, default parameter values used. ... Additional arguments passed rproc2fdata, allowing customization process generation.","code":""},{"path":"/reference/rproc2clust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Functional Data for Clustering — rproc2clust","text":"list containing following elements: X: functional data fdata object. X.hat: estimated mean functions group. group: theoretical functions group. groups: group labels curve. color: colors associated group. colors: colors assigned individual curve.","code":""},{"path":"/reference/rproc2clust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Functional Data for Clustering — rproc2clust","text":"","code":"fproces <- rproc2mu( 51, \"sin\", \"cos\", 1, 1) res <- rproc2clust (10,50,fproces$mu.1,fproces$mu.2) plot(res$X, col=res$groups) lines(res$X.hat, lwd=2, col=res$color)   fproces <- rproc2mu( 51, \"sin\", \"sin\", 1, 2) res <- rproc2clust (10,50,fproces$mu.1,fproces$mu.2) plot(res$X, col=res$groups) lines(res$X.hat, lwd=2, col=res$color)   fproces <- rproc2mu( 101, \"poly1\", \"poly1\", 10, -10, 1, 1) res <- rproc2clust (10,50,fproces$mu.1,fproces$mu.2) plot(res$X, col=res$colors) lines(res$X.hat, lwd=2, col=res$color)   fproces <- rproc2mu( 101, \"poly1\", \"poly1\", 10, -10, 1, 1) res <- rproc2clust (10,50,fproces$mu.1,fproces$mu.2,\"vexponential\",\"vexponential\") #> Error in svd(t(sigma)): infinite or missing values in 'x' plot(res$X, col=res$colors) lines(res$X.hat, lwd=2, col=res$color)   fproces <- rproc2mu( 101, \"poly1\", \"poly2\", -3, 3, 1, 1.4) res <- rproc2clust (50,50,fproces$mu.1,fproces$mu.2,\"brownian\",\"brownian\") #> Error in C$u %*% diag(sqrt(C$d)): non-conformable arguments plot(res$X, col=res$colors) lines(res$X.hat, lwd=2, col=res$color)   par.list.1 <- list(scale = 0.8, theta = 0.3, H = 0.5) par.list.2 <- list(scale = 0.2, theta = 0.3, H = 0.5) fproces <- rproc2mu( 101, \"poly1\", \"poly2\", -3, 3, 1, 1.4) res <- rproc2clust (50,50,fproces$mu.1,fproces$mu.2,                     \"brownian\",\"brownian\", par.list.1, par.list.2) #> Error in C$u %*% diag(sqrt(C$d)): non-conformable arguments plot(res$X, col=res$colors) lines(res$X.hat, lwd=2, col=res$color)"},{"path":"/reference/rproc2mu.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Latent Processes for Functional Data — rproc2mu","title":"Generate Latent Processes for Functional Data — rproc2mu","text":"Generates two latent processes (mu.1 mu.2) based specified input parameters, including process type, coefficients,  exponents, number evaluation points.","code":""},{"path":"/reference/rproc2mu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Latent Processes for Functional Data — rproc2mu","text":"","code":"rproc2mu(   t,   process1 = \"poly1\",   process2 = \"poly2\",   c.1,   c.2,   k.1 = NULL,   k.2 = NULL )"},{"path":"/reference/rproc2mu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Latent Processes for Functional Data — rproc2mu","text":"t numeric vector specifying grid points (argvals) latent processes evaluated. process1, process2 Character strings specifying types first second latent processes, respectively. Available options include \"poly1\" (default), \"poly2\"  (default), \"sin\", \"cos\". c.1, c.2 Numeric coefficients used scale first second latent processes, respectively. k.1, k.2 Optional numeric exponents used first second latent processes, respectively. exponents control shape curvature processes, applicable \"poly1\"  \"poly2\" process types.","code":""},{"path":"/reference/rproc2mu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Latent Processes for Functional Data — rproc2mu","text":"list containing following elements: mu.1: fdata object representing first latent process. mu.2: fdata object representing second latent process.","code":""},{"path":"/reference/rproc2mu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Latent Processes for Functional Data — rproc2mu","text":"available latent process types described follows: \"poly1\": polynomial process form \\(\\mu_1(t) = c_1 \\cdot (1 - t) \\cdot t^{k_1}\\),   c.1 scaling coefficient k.1 controls curvature process. \"poly2\": polynomial process form \\(\\mu_2(t) = c_2 \\cdot (1 - t)^{k_2} \\cdot t\\),   c.2 scaling coefficient k.2 controls curvature process. \"sin\": sinusoidal process form \\(\\mu_i(t) = c_i \\cdot \\sin(t)\\),   c.scaling coefficient adjusts amplitude sinusoidal wave. \"cos\": cosine process form \\(\\mu_i(t) = c_i \\cdot \\cos(t)\\),   c.scaling coefficient adjusts amplitude cosine wave. \"sin_cos\": combination sinusoidal cosine processes   form \\(\\mu_1(t) = c_i \\cdot (\\sin(t) - \\cos(t))\\),   c.scaling coefficient. \"cos_sin\": combination cosine sinusoidal processes   form \\(\\mu_2(t) = c_i \\cdot (\\cos(t) - \\sin(t))\\),   c.scaling coefficient.","code":""},{"path":"/reference/rproc2mu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Latent Processes for Functional Data — rproc2mu","text":"","code":"# Example 1: Generate latent processes using poly1 and poly1 np <- 101 t1 <- seq(0, 1, length.out = np) fproces <- rproc2mu(t1, \"poly1\", \"poly1\", 10, -10, 1, 1) plot(fproces$mu.1, col = \"blue\",        main = \"Latent Processes\",       ylim=range(cbind(range(fproces$mu.1),range(fproces$mu.2)))) lines(fproces$mu.2, col = \"red\")   # Example 2: Generate latent processes using poly1 and poly2 fproces <- rproc2mu(t1, \"poly1\", \"poly2\", 1.1, 1, 1, 1) plot(fproces$mu.1, col = \"blue\", main = \"Latent Processes\") lines(fproces$mu.2, col = \"red\")   # Example 3: Generate latent processes using sin and cos t2 <- seq(0, pi, len = np) fproces <- rproc2mu(t2, \"sin\", \"cos\", 1, 1) plot(fproces$mu.1, col = \"blue\", main = \"Latent Processes\") lines(fproces$mu.2, col = \"red\")   # Example 4: Generate latent processes using sin and cos t3 <- seq(0, 2 * pi, len = np) fproces <- rproc2mu(t2, \"cos\", \"cos_sin\", 1, 1) plot(fproces$mu.1, col = \"blue\", main = \"Latent Processes\") lines(fproces$mu.2, col = \"red\")"},{"path":"/reference/rprocKclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Functional Data for K Clusters — rprocKclust","title":"Simulate Functional Data for K Clusters — rprocKclust","text":"Simulates functional data K clusters based specified parameters clustering analysis within `fda.clust` package. uses `rprocKmu` generate latent processes `rproc2fdata` `fda.usc` generate functional data.","code":""},{"path":"/reference/rprocKclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Functional Data for K Clusters — rprocKclust","text":"","code":"rprocKclust(t, n, process, c, k = NULL, s = 1, par.list = NULL, ...)"},{"path":"/reference/rprocKclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Functional Data for K Clusters — rprocKclust","text":"t numeric vector representing evaluation points (argvals) functional data computed. n vector integers specifying number curves generated K clusters. process character vector length K specifying type latent process. Options include \"poly1\", \"poly2\", \"sin\", \"cos\", \"sin_cos\", \"cos_sin\". c numeric vector length K specifying coefficients process. k optional numeric vector length K specifying exponents processes. parameter relevant \"poly1\" \"poly2\". s numeric vector specifying standard deviation noise added cluster's data. one value provided, recycled clusters. par.list list lists additional parameters passed rproc2fdata generating functional data cluster. ... Additional arguments passed rproc2fdata, allowing customization process generation.","code":""},{"path":"/reference/rprocKclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Functional Data for K Clusters — rprocKclust","text":"list containing following elements: X: functional data fdata object. X.hat: estimated mean functions cluster. groups: group labels curve. color: colors associated cluster. colors: colors assigned individual curve.","code":""},{"path":"/reference/rprocKclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Functional Data for K Clusters — rprocKclust","text":"","code":"t <- seq(0, 2*pi, length.out = 101) res <- rprocKclust(t,                     n = c(30, 50, 40),                     process = c(\"poly1\", \"sin\", \"cos\"),                     c = c(10, 1, 1),                     k = c(2, NA, NA),                     s = c(0.2, 0.3, 0.1))  plot(res$X, col = res$colors) lines(res$X.hat, lwd = 2, col = res$color)"},{"path":"/reference/rprocKmu.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Latent Processes for Functional Data — rprocKmu","title":"Generate Latent Processes for Functional Data — rprocKmu","text":"Generates multiple latent processes (mu.1, mu.2, ..., mu.k) based specified input parameters, including process type, coefficients, exponents, number evaluation points.","code":""},{"path":"/reference/rprocKmu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Latent Processes for Functional Data — rprocKmu","text":"","code":"rprocKmu(t, process, c, k = NULL)"},{"path":"/reference/rprocKmu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Latent Processes for Functional Data — rprocKmu","text":"t numeric vector specifying grid points (argvals) latent processes evaluated. process character vector specifying types latent processes. Available options include \"poly1\", \"poly2\", \"sin\", \"cos\", \"sin_cos\", \"cos_sin\". c numeric vector coefficients used scale latent processes. k optional numeric vector exponents used latent processes. exponents control shape curvature processes, applicable \"poly1\" \"poly2\" process types.","code":""},{"path":"/reference/rprocKmu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Latent Processes for Functional Data — rprocKmu","text":"list containing following elements: mu: list fdata objects, representing one   latent processes.","code":""},{"path":"/reference/rprocKmu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Latent Processes for Functional Data — rprocKmu","text":"available latent process types described follows: \"poly1\": \\(\\mu_i(t) = c_i \\cdot (1 - t) \\cdot t^{k_i}\\),   c.scaling coefficient k.controls curvature. \"poly2\": \\(\\mu_i(t) = c_i \\cdot (1 - t)^{k_i} \\cdot t\\),   c.scaling coefficient k.controls curvature. \"sin\": \\(\\mu_i(t) = c_i \\cdot \\sin(t)\\),   c.scaling coefficient adjusts amplitude. \"cos\": \\(\\mu_i(t) = c_i \\cdot \\cos(t)\\),   c.scaling coefficient adjusts amplitude. \"sin_cos\": \\(\\mu_i(t) = c_i \\cdot (\\sin(t) - \\cos(t))\\),   c.scaling coefficient. \"cos_sin\": \\(\\mu_i(t) = c_i \\cdot (\\cos(t) - \\sin(t))\\),   c.scaling coefficient.","code":""},{"path":"/reference/rprocKmu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Latent Processes for Functional Data — rprocKmu","text":"","code":"t <- seq(0, 1, length.out = 101) fproces <- rprocKmu(t, c(\"poly1\", \"poly2\", \"sin\", \"cos\"),                      c(10, -10, 1, 1), c(1, 1, NA, NA)) plot(fproces, main = \"Latent Processes\")"}]
